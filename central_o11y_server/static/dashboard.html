<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Decentralized System Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .chart-container {
      width: 100%;
      max-width: 900px;
      margin-bottom: 40px;
    }
    .reset-link {
      display: block;
      text-align: center;
      margin-top: 15px;
      margin-bottom: 20px;
      font-size: 0.9em;
      text-decoration: underline;
      color: #007bff;
      cursor: pointer;
    }
    table {
      border-collapse: collapse;
      margin-top: 10px;
      margin-bottom: 40px;
    }
    th, td {
      padding: 6px 12px;
      border: 1px solid #ccc;
      text-align: center;
    }
    th {
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <h1>üöÄ System Metrics Dashboard</h1>

  <h2>üìä Per-Node Metrics Over Time</h2>
  <div class="chart-container"><canvas id="cpuChart"></canvas><a class="reset-link" href="#" onclick="cpuChart.resetZoom()">Reset Zoom</a></div>
    <!-- ‚úÖ CPU Summary Table -->
    <h3>üßÆ CPU Summary (Per Node)</h3>
    <table id="cpuSummaryTable">
        <thead>
        <tr>
            <th>Node</th>
            <th>Avg CPU %</th>
            <th>Max CPU %</th>
            <th>Latest CPU %</th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
  <div class="chart-container"><canvas id="memChart"></canvas><a class="reset-link" href="#" onclick="memChart.resetZoom()">Reset Zoom</a></div>
    <!-- ‚úÖ Memory Summary Table -->
    <h3>üß† Memory Summary (Per Node)</h3>
    <table id="memSummaryTable">
        <thead>
        <tr>
            <th>Node</th>
            <th>Avg Mem %</th>
            <th>Max Mem %</th>
            <th>Latest Mem %</th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
  <div class="chart-container"><canvas id="queueChart"></canvas><a class="reset-link" href="#" onclick="queueChart.resetZoom()">Reset Zoom</a></div>
    <!-- ‚úÖ Queue Length Summary Table -->
    <h3>üì¶ Queue Length Summary (Per Node)</h3>
    <table id="queueSummaryTable">
        <thead>
        <tr>
            <th>Node</th>
            <th>Avg Queue</th>
            <th>Max Queue</th>
            <th>Latest Queue</th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
  <div class="chart-container"><canvas id="localProcChart"></canvas><a class="reset-link" href="#" onclick="localProcChart.resetZoom()">Reset Zoom</a></div>
    <!-- ‚úÖ Local Processings Summary Table -->
    <h3>‚öôÔ∏è Local Processing Summary (Per Node)</h3>
    <table id="localProcSummaryTable">
    <thead>
        <tr>
        <th>Node</th>
        <th>Total Jobs</th>
        <th>Avg / 5s</th>
        <th>Max Burst</th>
        </tr>
    </thead>
    <tbody></tbody>
    </table>
  <div class="chart-container"><canvas id="offloadSameChart"></canvas><a class="reset-link" href="#" onclick="offloadSameChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="offloadCrossChart"></canvas><a class="reset-link" href="#" onclick="offloadCrossChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="cacheHitsChart"></canvas><a class="reset-link" href="#" onclick="cacheHitsChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="cacheMissesChart"></canvas><a class="reset-link" href="#" onclick="cacheMissesChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sameRespChart"></canvas><a class="reset-link" href="#" onclick="sameRespChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="crossRespChart"></canvas><a class="reset-link" href="#" onclick="crossRespChart.resetZoom()">Reset Zoom</a></div>

  <h2>üåê System-Wide Metrics Over Time</h2>
  <div class="chart-container"><canvas id="sysCpuChart"></canvas><a class="reset-link" href="#" onclick="sysCpuChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysMemChart"></canvas><a class="reset-link" href="#" onclick="sysMemChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysOffloadChart"></canvas><a class="reset-link" href="#" onclick="sysOffloadChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysCacheChart"></canvas><a class="reset-link" href="#" onclick="sysCacheChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysLocalProcChart"></canvas><a class="reset-link" href="#" onclick="sysLocalProcChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysRespChart"></canvas><a class="reset-link" href="#" onclick="sysRespChart.resetZoom()">Reset Zoom</a></div>

  <script>
    const MAX_POINTS = 1500;

    const perNodeMetrics = {
      cpu: {}, mem: {}, queue: {}, localProc: {},
      offSame: {}, offCross: {}, cacheHits: {}, cacheMisses: {},
      sameResp: {}, crossResp: {}
    };

    const sysMetrics = {
      timeLabels: [], cpu: [], mem: [], offSame: [], offCross: [],
      cacheHits: [], cacheMisses: [], localProc: [],
      sameResp: [], crossResp: []
    };

    const cpuStats = {}; // Store CPU history for each node
    const memStats = {}; // Store Memory history for each node
    const queueStats = {}; // Store Queue history for each node
    const localProcStats = {};
    const prevLocalProc = {};


    async function fetchMetrics() {
      const res = await fetch('/metrics');
      return res.json();
    }

    const createLineChart = (id, title) =>
        new Chart(document.getElementById(id), {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                plugins: {
                    title: {
                        display: true,
                        text: title,
                        font: { size: 16 }
                    },
                    zoom: {
                        pan: { enabled: true, mode: 'x' },
                        zoom: { wheel: { enabled: true }, mode: 'x' },
                        limits: { x: { min: 'original', max: 'original' }, y: { min: 'original', max: 'original' } }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            tooltipFormat: 'HH:mm:ss',
                            displayFormats: { second: 'HH:mm:ss' }
                        }
                    },
                    y: { beginAtZero: true }
                }
            }
        });

    const cpuChart = createLineChart('cpuChart', 'CPU % per Node');
    const memChart = createLineChart('memChart', 'Memory % per Node');
    const queueChart = createLineChart('queueChart', 'Queue Length per Node');
    const localProcChart = createLineChart('localProcChart', 'Local Processings per Node');
    const offloadSameChart = createLineChart('offloadSameChart', 'Same-Region Offloads per Node');
    const offloadCrossChart = createLineChart('offloadCrossChart', 'Cross-Region Offloads per Node');
    const cacheHitsChart = createLineChart('cacheHitsChart', 'Cache Hits per Node');
    const cacheMissesChart = createLineChart('cacheMissesChart', 'Cache Misses per Node');
    const sameRespChart = createLineChart('sameRespChart', 'Same-Region Responses per Node');
    const crossRespChart = createLineChart('crossRespChart', 'Cross-Region Responses per Node');

    const sysCpuChart = createLineChart('sysCpuChart', 'Total CPU %');
    const sysMemChart = createLineChart('sysMemChart', 'Total Memory %');
    const sysOffloadChart = createLineChart('sysOffloadChart', 'Total Offloads');
    const sysCacheChart = createLineChart('sysCacheChart', 'Total Cache');
    const sysLocalProcChart = createLineChart('sysLocalProcChart', 'Total Local Processings');
    const sysRespChart = createLineChart('sysRespChart', 'Total Responses');

    function getOrCreateDataset(chart, nodeId, color) {
      let dataset = chart.data.datasets.find(d => d.label === nodeId);
      if (!dataset) {
        dataset = { label: nodeId, data: [], borderColor: color, backgroundColor: color + '33', fill: false };
        chart.data.datasets.push(dataset);
      }
      return dataset;
    }

    function updatePerNodeChart(chart, metricStore, metricKey, ts, colorMap) {
      for (const [nodeId, value] of Object.entries(metricStore)) {
        if (!perNodeMetrics[metricKey][nodeId]) perNodeMetrics[metricKey][nodeId] = [];
        perNodeMetrics[metricKey][nodeId].push({ x: ts, y: value });
        if (perNodeMetrics[metricKey][nodeId].length > MAX_POINTS) {
          perNodeMetrics[metricKey][nodeId].shift();
        }
        const dataset = getOrCreateDataset(chart, nodeId, colorMap[nodeId] || 'gray');
        dataset.data = perNodeMetrics[metricKey][nodeId];
      }
      chart.update();
    }

    function sum(values) {
      return values.reduce((a, b) => a + b, 0);
    }

    function updateSystemChart(chart, label, data, color, index = 0) {
      if (chart.data.datasets.length <= index) {
        chart.data.datasets.push({
          label,
          data: [],
          borderColor: color,
          backgroundColor: color + '33',
          fill: false
        });
      }
      chart.data.labels = sysMetrics.timeLabels;
      chart.data.datasets[index].data = data;
      chart.update();
    }

    function updateCpuSummaryTable(latestCpuData) {
      const tbody = document.querySelector('#cpuSummaryTable tbody');
      tbody.innerHTML = '';

      Object.entries(latestCpuData).forEach(([nodeId, latestValue]) => {
        if (!cpuStats[nodeId]) cpuStats[nodeId] = [];
        const history = cpuStats[nodeId];
        history.push(latestValue);
        if (history.length > MAX_POINTS) history.shift();

        const avg = (history.reduce((a, b) => a + b, 0) / history.length).toFixed(1);
        const max = Math.max(...history).toFixed(1);

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${nodeId}</td>
          <td>${avg}%</td>
          <td>${max}%</td>
          <td>${latestValue.toFixed(1)}%</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function updateMemSummaryTable(latestMemData) {
      const tbody = document.querySelector('#memSummaryTable tbody');
      tbody.innerHTML = '';

      Object.entries(latestMemData).forEach(([nodeId, latestValue]) => {
        if (!memStats[nodeId]) memStats[nodeId] = [];
        const history = memStats[nodeId];
        history.push(latestValue);
        if (history.length > MAX_POINTS) history.shift();

        const avg = (history.reduce((a, b) => a + b, 0) / history.length).toFixed(1);
        const max = Math.max(...history).toFixed(1);

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${nodeId}</td>
          <td>${avg}%</td>
          <td>${max}%</td>
          <td>${latestValue.toFixed(1)}%</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function updateQueueSummaryTable(latestQueueData) {
        const tbody = document.querySelector('#queueSummaryTable tbody');
        tbody.innerHTML = '';

        Object.entries(latestQueueData).forEach(([nodeId, latestValue]) => {
            if (!queueStats[nodeId]) queueStats[nodeId] = [];
            const history = queueStats[nodeId];
            history.push(latestValue);
            if (history.length > MAX_POINTS) history.shift();

            const avg = (history.reduce((a, b) => a + b, 0) / history.length).toFixed(1);
            const max = Math.max(...history).toFixed(1);

            const tr = document.createElement('tr');
            tr.innerHTML = `
            <td>${nodeId}</td>
            <td>${avg}</td>
            <td>${max}</td>
            <td>${latestValue}</td>
            `;
            tbody.appendChild(tr);
        });
    }

    function updateLocalProcSummaryTable(latestProcData) {
        const tbody = document.querySelector('#localProcSummaryTable tbody');
        tbody.innerHTML = '';

        Object.entries(latestProcData).forEach(([nodeId, currentValue]) => {
            if (!localProcStats[nodeId]) localProcStats[nodeId] = [];

            const prevValue = prevLocalProc[nodeId] ?? 0;  // initialize on first run
            const delta = Math.max(currentValue - prevValue, 0);       // avoid negative spikes

            prevLocalProc[nodeId] = currentValue;
            localProcStats[nodeId].push(delta);

            if (localProcStats[nodeId].length > MAX_POINTS) {
            localProcStats[nodeId].shift();
            }

            const history = localProcStats[nodeId];
            const total = history.reduce((a, b) => a + b, 0);
            const avg = (total / history.length).toFixed(1);
            const max = Math.max(...history);

            const tr = document.createElement('tr');
            tr.innerHTML = `
            <td>${nodeId}</td>
            <td>${total}</td>
            <td>${avg}</td>
            <td>${max}</td>
            `;
            tbody.appendChild(tr);
        });
    }

    async function updateCharts() {
      const data = await fetchMetrics();
      const ts = new Date();
      const nodeIds = Object.keys(data);
      const colorPalette = ['orange', 'green', 'blue', 'red', 'purple', 'teal', 'pink', 'brown'];
      const colorMap = Object.fromEntries(nodeIds.map((id, i) => [id, colorPalette[i % colorPalette.length]]));

      const cpu = {}, mem = {}, queue = {}, localProc = {}, offSame = {}, offCross = {}, cacheHits = {}, cacheMisses = {}, sameResp = {}, crossResp = {};

      nodeIds.forEach(id => {
        cpu[id] = data[id].cpu_load || 0;
        mem[id] = data[id].memory_usage || 0;
        queue[id] = data[id].queue_length || 0;
        localProc[id] = data[id].local_processings || 0;
        offSame[id] = data[id].offloads_same_region || 0;
        offCross[id] = data[id].offloads_cross_region || 0;
        cacheHits[id] = data[id].cache_hits || 0;
        cacheMisses[id] = data[id].cache_misses || 0;
        sameResp[id] = data[id].same_region_responses || 0;
        crossResp[id] = data[id].cross_region_responses || 0;
      });

      updatePerNodeChart(cpuChart, cpu, 'cpu', ts, colorMap);
      updatePerNodeChart(memChart, mem, 'mem', ts, colorMap);
      updatePerNodeChart(queueChart, queue, 'queue', ts, colorMap);
      updatePerNodeChart(localProcChart, localProc, 'localProc', ts, colorMap);
      updatePerNodeChart(offloadSameChart, offSame, 'offSame', ts, colorMap);
      updatePerNodeChart(offloadCrossChart, offCross, 'offCross', ts, colorMap);
      updatePerNodeChart(cacheHitsChart, cacheHits, 'cacheHits', ts, colorMap);
      updatePerNodeChart(cacheMissesChart, cacheMisses, 'cacheMisses', ts, colorMap);
      updatePerNodeChart(sameRespChart, sameResp, 'sameResp', ts, colorMap);
      updatePerNodeChart(crossRespChart, crossResp, 'crossResp', ts, colorMap);

      updateCpuSummaryTable(cpu);
      updateMemSummaryTable(mem);
      updateQueueSummaryTable(queue);
      updateLocalProcSummaryTable(localProc);

      sysMetrics.timeLabels.push(ts);
      sysMetrics.cpu.push(sum(Object.values(cpu)));
      sysMetrics.mem.push(sum(Object.values(mem)));
      sysMetrics.offSame.push(sum(Object.values(offSame)));
      sysMetrics.offCross.push(sum(Object.values(offCross)));
      sysMetrics.cacheHits.push(sum(Object.values(cacheHits)));
      sysMetrics.cacheMisses.push(sum(Object.values(cacheMisses)));
      sysMetrics.localProc.push(sum(Object.values(localProc)));
      sysMetrics.sameResp.push(sum(Object.values(sameResp)));
      sysMetrics.crossResp.push(sum(Object.values(crossResp)));

      if (sysMetrics.timeLabels.length > MAX_POINTS) {
        Object.keys(sysMetrics).forEach(k => sysMetrics[k].shift());
      }

      updateSystemChart(sysCpuChart, 'Total CPU', sysMetrics.cpu, 'orange');
      updateSystemChart(sysMemChart, 'Total Memory', sysMetrics.mem, 'green');
      updateSystemChart(sysOffloadChart, 'Same-Region', sysMetrics.offSame, 'blue', 0);
      updateSystemChart(sysOffloadChart, 'Cross-Region', sysMetrics.offCross, 'red', 1);
      updateSystemChart(sysCacheChart, 'Hits', sysMetrics.cacheHits, 'teal', 0);
      updateSystemChart(sysCacheChart, 'Misses', sysMetrics.cacheMisses, 'pink', 1);
      updateSystemChart(sysLocalProcChart, 'Total Local Proc', sysMetrics.localProc, 'purple');
      updateSystemChart(sysRespChart, 'Same-Region', sysMetrics.sameResp, 'blue', 0);
      updateSystemChart(sysRespChart, 'Cross-Region', sysMetrics.crossResp, 'red', 1);
    }

    setInterval(updateCharts, 5000);
    updateCharts();
  </script>
</body>
</html>
