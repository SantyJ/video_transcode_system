<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Decentralized System Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .chart-container {
      width: 100%;
      max-width: 900px;
      margin-bottom: 40px;
    }
    .reset-link {
        display: block;
        text-align: center;
        margin-top: 15px;
        margin-bottom: 20px;
        font-size: 0.9em;
        text-decoration: underline;
        color: #007bff;
        cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>üöÄ System Metrics Dashboard</h1>

  <h2>üìä Per-Node Metrics Over Time</h2>
  <div class="chart-container"><canvas id="cpuChart"></canvas><a class="reset-link" href="#" onclick="cpuChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="memChart"></canvas><a class="reset-link" href="#" onclick="memChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="queueChart"></canvas><a class="reset-link" href="#" onclick="queueChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="localProcChart"></canvas><a class="reset-link" href="#" onclick="localProcChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="offloadSameChart"></canvas><a class="reset-link" href="#" onclick="offloadSameChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="offloadCrossChart"></canvas><a class="reset-link" href="#" onclick="offloadCrossChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="cacheHitsChart"></canvas><a class="reset-link" href="#" onclick="cacheHitsChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="cacheMissesChart"></canvas><a class="reset-link" href="#" onclick="cacheMissesChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sameRespChart"></canvas><a class="reset-link" href="#" onclick="sameRespChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="crossRespChart"></canvas><a class="reset-link" href="#" onclick="crossRespChart.resetZoom()">Reset Zoom</a></div>
  
  <h2>üåê System-Wide Metrics Over Time</h2>
  <div class="chart-container"><canvas id="sysCpuChart"></canvas><a class="reset-link" href="#" onclick="sysCpuChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysMemChart"></canvas><a class="reset-link" href="#" onclick="sysMemChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysOffloadChart"></canvas><a class="reset-link" href="#" onclick="sysOffloadChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysCacheChart"></canvas><a class="reset-link" href="#" onclick="sysCacheChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysLocalProcChart"></canvas><a class="reset-link" href="#" onclick="sysLocalProcChart.resetZoom()">Reset Zoom</a></div>
  <div class="chart-container"><canvas id="sysRespChart"></canvas><a class="reset-link" href="#" onclick="sysRespChart.resetZoom()">Reset Zoom</a></div>

  <script>
    // Register Charts with zooming plugin
    // Chart.register(zoomPlugin);
    // Chart.register(window['chartjs-plugin-zoom'])

    const MAX_POINTS = 1500;

    const perNodeMetrics = {
      cpu: {}, mem: {}, queue: {}, localProc: {},
      offSame: {}, offCross: {}, cacheHits: {}, cacheMisses: {},
      sameResp: {}, crossResp: {}
    };

    const sysMetrics = {
      timeLabels: [], cpu: [], mem: [], offSame: [], offCross: [],
      cacheHits: [], cacheMisses: [], localProc: [],
      sameResp: [], crossResp: []
    };

    async function fetchMetrics() {
      const res = await fetch('/metrics');
      return res.json();
    }

    const createLineChart = (id, title) =>
        new Chart(document.getElementById(id), {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                plugins: {
                    title: {
                        display: true,
                        text: title,
                        font: { size: 16 }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x',
                            modifierKey: null // optional
                        },
                        zoom: {
                            wheel: { enabled: true },
                            // drag: { enabled: true }, // enables drag-zoom
                            mode: 'x'
                        },
                        limits: {
                            x: { min: 'original', max: 'original' },
                            y: { min: 'original', max: 'original' }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            tooltipFormat: 'HH:mm:ss',
                            displayFormats: { second: 'HH:mm:ss' }
                        }
                    },
                    y: { beginAtZero: true }
                }
            }
        });

    const cpuChart = createLineChart('cpuChart', 'CPU % per Node');
    const memChart = createLineChart('memChart', 'Memory % per Node');
    const queueChart = createLineChart('queueChart', 'Queue Length per Node');
    const localProcChart = createLineChart('localProcChart', 'Local Processings per Node');
    const offloadSameChart = createLineChart('offloadSameChart', 'Same-Region Offloads per Node');
    const offloadCrossChart = createLineChart('offloadCrossChart', 'Cross-Region Offloads per Node');
    const cacheHitsChart = createLineChart('cacheHitsChart', 'Cache Hits per Node');
    const cacheMissesChart = createLineChart('cacheMissesChart', 'Cache Misses per Node');
    const sameRespChart = createLineChart('sameRespChart', 'Same-Region Responses per Node');
    const crossRespChart = createLineChart('crossRespChart', 'Cross-Region Responses per Node');

    const sysCpuChart = createLineChart('sysCpuChart', 'Total CPU %');
    const sysMemChart = createLineChart('sysMemChart', 'Total Memory %');
    const sysOffloadChart = createLineChart('sysOffloadChart', 'Total Offloads');
    const sysCacheChart = createLineChart('sysCacheChart', 'Total Cache');
    const sysLocalProcChart = createLineChart('sysLocalProcChart', 'Total Local Processings');
    const sysRespChart = createLineChart('sysRespChart', 'Total Responses');

    function getOrCreateDataset(chart, nodeId, color) {
      let dataset = chart.data.datasets.find(d => d.label === nodeId);
      if (!dataset) {
        dataset = { label: nodeId, data: [], borderColor: color, backgroundColor: color + '33', fill: false };
        chart.data.datasets.push(dataset);
      }
      return dataset;
    }

    function updatePerNodeChart(chart, metricStore, metricKey, ts, colorMap) {
      for (const [nodeId, value] of Object.entries(metricStore)) {
        if (!perNodeMetrics[metricKey][nodeId]) perNodeMetrics[metricKey][nodeId] = [];
        perNodeMetrics[metricKey][nodeId].push({ x: ts, y: value });
        if (perNodeMetrics[metricKey][nodeId].length > MAX_POINTS) {
          perNodeMetrics[metricKey][nodeId].shift();
        }
        const dataset = getOrCreateDataset(chart, nodeId, colorMap[nodeId] || 'gray');
        dataset.data = perNodeMetrics[metricKey][nodeId];
      }
      chart.update();
    }

    function sum(values) {
      return values.reduce((a, b) => a + b, 0);
    }

    function updateSystemChart(chart, label, data, color, index = 0) {
      if (chart.data.datasets.length <= index) {
        chart.data.datasets.push({
          label,
          data: [],
          borderColor: color,
          backgroundColor: color + '33',
          fill: false
        });
      }
      chart.data.labels = sysMetrics.timeLabels;
      chart.data.datasets[index].data = data;
      chart.update();
    }

    async function updateCharts() {
      const data = await fetchMetrics();
      const ts = new Date();
      const nodeIds = Object.keys(data);
      const colorPalette = ['orange', 'green', 'blue', 'red', 'purple', 'teal', 'pink', 'brown'];
      const colorMap = Object.fromEntries(nodeIds.map((id, i) => [id, colorPalette[i % colorPalette.length]]));

      const cpu = {}, mem = {}, queue = {}, localProc = {}, offSame = {}, offCross = {}, cacheHits = {}, cacheMisses = {}, sameResp = {}, crossResp = {};

      nodeIds.forEach(id => {
        cpu[id] = data[id].cpu_load || 0;
        mem[id] = data[id].memory_usage || 0;
        queue[id] = data[id].queue_length || 0;
        localProc[id] = data[id].local_processings || 0;
        offSame[id] = data[id].offloads_same_region || 0;
        offCross[id] = data[id].offloads_cross_region || 0;
        cacheHits[id] = data[id].cache_hits || 0;
        cacheMisses[id] = data[id].cache_misses || 0;
        sameResp[id] = data[id].same_region_responses || 0;
        crossResp[id] = data[id].cross_region_responses || 0;
      });

      updatePerNodeChart(cpuChart, cpu, 'cpu', ts, colorMap);
      updatePerNodeChart(memChart, mem, 'mem', ts, colorMap);
      updatePerNodeChart(queueChart, queue, 'queue', ts, colorMap);
      updatePerNodeChart(localProcChart, localProc, 'localProc', ts, colorMap);
      updatePerNodeChart(offloadSameChart, offSame, 'offSame', ts, colorMap);
      updatePerNodeChart(offloadCrossChart, offCross, 'offCross', ts, colorMap);
      updatePerNodeChart(cacheHitsChart, cacheHits, 'cacheHits', ts, colorMap);
      updatePerNodeChart(cacheMissesChart, cacheMisses, 'cacheMisses', ts, colorMap);
      updatePerNodeChart(sameRespChart, sameResp, 'sameResp', ts, colorMap);
      updatePerNodeChart(crossRespChart, crossResp, 'crossResp', ts, colorMap);

      sysMetrics.timeLabels.push(ts);
      sysMetrics.cpu.push(sum(Object.values(cpu)));
      sysMetrics.mem.push(sum(Object.values(mem)));
      sysMetrics.offSame.push(sum(Object.values(offSame)));
      sysMetrics.offCross.push(sum(Object.values(offCross)));
      sysMetrics.cacheHits.push(sum(Object.values(cacheHits)));
      sysMetrics.cacheMisses.push(sum(Object.values(cacheMisses)));
      sysMetrics.localProc.push(sum(Object.values(localProc)));
      sysMetrics.sameResp.push(sum(Object.values(sameResp)));
      sysMetrics.crossResp.push(sum(Object.values(crossResp)));

      if (sysMetrics.timeLabels.length > MAX_POINTS) {
        Object.keys(sysMetrics).forEach(k => sysMetrics[k].shift());
      }

      updateSystemChart(sysCpuChart, 'Total CPU', sysMetrics.cpu, 'orange');
      updateSystemChart(sysMemChart, 'Total Memory', sysMetrics.mem, 'green');
      updateSystemChart(sysOffloadChart, 'Same-Region', sysMetrics.offSame, 'blue', 0);
      updateSystemChart(sysOffloadChart, 'Cross-Region', sysMetrics.offCross, 'red', 1);
      updateSystemChart(sysCacheChart, 'Hits', sysMetrics.cacheHits, 'teal', 0);
      updateSystemChart(sysCacheChart, 'Misses', sysMetrics.cacheMisses, 'pink', 1);
      updateSystemChart(sysLocalProcChart, 'Total Local Proc', sysMetrics.localProc, 'purple');
      updateSystemChart(sysRespChart, 'Same-Region', sysMetrics.sameResp, 'blue', 0);
      updateSystemChart(sysRespChart, 'Cross-Region', sysMetrics.crossResp, 'red', 1);
    }

    setInterval(updateCharts, 5000);
    updateCharts();
  </script>
</body>
</html>
